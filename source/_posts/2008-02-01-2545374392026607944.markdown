---
layout: post
title: Little Erlang Exercise 5
date:  2008-02-01 23:17
comments: true
categories: erlang
meta: 
---
Problem Definition: <a href="http://projecteuler.net/index.php?section=problems&amp;id=5">Euler Problem 5</a><br /><br />I am rather happy with this python version because I can basically get it done in about 15 min in total. Some useful primitives have been developed in module p3 (See my previous post, <a href="http://www.blogger.com/2008/01/little-erlange-exercise-3_29.html">little erlang exercise 3</a>)<br /><br /><pre style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; font-family: Andale Mono,Lucida Console,Monaco,fixed,monospace; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); font-size: 12px; line-height: 14px; width: 100%;"><code><br />"""<br />2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.<br /><br />What is the smallest number that is evenly divisible by all of the numbers from 1 to 20?<br />"""<br /><br /><br />from p3 import isprime, factorise<br /><br />def product(x, y):<br /> return x * y<br /><br />if __name__ == "__main__":<br /> factors = dict()<br /> for l in [factorise(i) for i in xrange(2, 21)]:<br />     tmp = dict()<br />     # count them<br />     for n in l:<br />         tmp[n] = 1 + tmp.get(n, 0)<br />     # reguster the max frequency of factor<br />     for k, v in tmp.items():<br />         factors[k] = max(factors.get(k, 0), v)<br /><br /> print reduce(product, [pow(k, v) for k,v in factors.items()])<br /><br /></code></pre><br /><br />However, the erlang version took me a considerable time to complete. The problem is mainly to switch from a procedural mindset to a functional mindset.<br /><br /><br /><pre style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; font-family: Andale Mono,Lucida Console,Monaco,fixed,monospace; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); font-size: 12px; line-height: 14px; width: 100%;"><code><br /><br />-module(p5).<br />-import(p3).<br />-export([main/0, get_factor_freq_lst/1]).<br /><br />%% run this to print the result<br />main() -><br />  L = [ p3:factorise(X) || X <- lists:seq(1, 20)],   <br />  io:format("~f~n", [product(get_factor_freq(L))]).   <br /><br />get_factor_freq(L) -><br />  Dict = dict:new(),<br />  get_factor_freq(L, Dict).<br /><br />%% spec: H, T are list of list of number<br />%% e.g. [ [N1, N1, N2...], [N1, N2...], ...]<br />get_factor_freq([H|T], Dict) -><br />  Dist = get_factor_freq_lst(H),<br />  D1 = dict:from_list(Dist),<br />  D2 = dict:merge(fun(K, X, Y) -> update_if_bigger(K, X, Y) end, D1, Dict),<br />  get_factor_freq(T, D2);<br />get_factor_freq([], Dict) -><br />  dict:to_list(Dict).  %% has to convert to list<br /><br />%% Aux function<br />update_if_bigger(_, Initial, NewValue) when Initial < NewValue -><br />  NewValue;<br />update_if_bigger(_, Initial, _) -><br />  Initial.<br /><br />%% This function assumes the list is sorted<br />%% This function is to delinate a list of number<br />%% into a list of {Key, Frequency}<br />get_factor_freq_lst([A|T]) when is_integer(A) -><br />  get_factor_freq_lst([{A, 1}|T]);<br />get_factor_freq_lst([{A, N}, A|T]) when is_integer(A) -><br />  get_factor_freq_lst([{A, N + 1}|T]);<br />get_factor_freq_lst([{A, N}, B|T]) when is_integer(A), is_integer(B), A /= B -><br />  get_factor_freq_lst([{B, 1}|T] ++ [{A, N}] );<br />get_factor_freq_lst(L) -><br />  L.<br /><br />%% find the product of a list of tuple {Base, Power)<br />product(L) -><br />  product(L, 1).<br />product([], Sum) -><br />  Sum;<br />product([{Base, Power}|T], Sum) -><br />  product(T, Sum * math:pow(Base, Power)).<br /><br /><br /></code></pre>