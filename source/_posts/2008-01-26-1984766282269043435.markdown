---
layout: post
title: Little Erlang Exercise 2
date:  2008-01-26 14:22
comments: true
categories: erlang euler
meta: 
---
Problem Definition: <a href="http://projecteuler.net/index.php?section=problems&amp;id=2">Euler Problem 2</a><br /><br />In order to solve this problem in python, I have used the yield keyword to implements a generator to provide a sequence of Fibonacci's numbers. I think I can do a better work in using list comprehension in the main routine to filter and add up the even numbers, but the current version is basically good enough.<br /><br /><pre style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; font-family: Andale Mono,Lucida Console,Monaco,fixed,monospace; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); font-size: 12px; line-height: 14px; width: 100%;"><code>"""<br /><br />Euler 2<br /><br />Each new term in the Fibonacci sequence is generated by adding the previous two terms.<br />By starting with 1 and 2, the first 10 terms will be:<br /><br />1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...<br /><br />Find the sum of all the even-valued terms in the sequence which<br />do not exceed one million.<br /><br /><br />"""<br />def gen_fib_seq():<br />a = 1<br />b = 2<br />yield a<br />yield b<br />try:<br /> while 1:<br />   c = a + b<br />   a, b = b, c<br />   yield c<br />except StopIteration:<br /> pass<br /><br /><br />if __name__ == "__main__":<br />b = 0<br />onemillion = 1000000<br />for x in gen_fib_seq():<br /> if x % 2 == 0:<br />   if b + x &lt; onemillion:<br />     b = b + x<br />   else:<br />     break<br />print b<br /><br /><br /></code></pre><br /><br /><br /><br />The erlang turns out to be even simpler than I thought. First of all, because every object or operation can be abstracted as a process, I do not need special keyword 'yield' to create a special object - generator. Furthermore the guard clause of  function <span style="font-weight: bold;">acc </span>remove the need to put in any 'if' or 'break' to do, for example, the even number testing as in the python version.<br /><br /><pre style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; font-family: Andale Mono,Lucida Console,Monaco,fixed,monospace; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); font-size: 12px; line-height: 14px; width: 100%;"><code>-module(p2).<br />-export([main/0]).<br /><br />start() -&gt; spawn(fun() -&gt; fib(0, 1) end).<br /><br />fib(N, M) -&gt;<br />receive<br /> {Pid, next} -&gt;<br />   Pid ! {self(), N + M},<br />   fib(M, N+ M)<br />end.<br /><br />get_next_fib(Pid) -&gt;<br />Pid ! {self(), next},<br />receive<br /> {_, N} -&gt;<br />   %% io:format("~p~n", [N])<br />   N<br />end.<br /><br />%% accumulator<br />acc(N, Pid, Acc) when (N rem 2) =:= 1 -&gt;<br /> N1 = get_next_fib(Pid),<br /> acc(N1, Pid, Acc);<br />acc(N, Pid, Acc) when N + Acc &lt; 1000000 -&gt;<br /> N1 = get_next_fib(Pid),<br /> acc(N1, Pid, Acc + N);<br />acc(_, _, Acc) -&gt;<br /> Acc.<br /><br /><br />%%%<br />%%% Program main()<br />%%%<br />main() -&gt;<br /> Pid = start(),<br /> Acc = acc(1, Pid, 0),<br /> Acc.<br /><br /><br /></code></pre>
