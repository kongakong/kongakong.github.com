---
layout: post
title: Little Erlang Exercise 3
date:  2008-01-29 22:09
comments: true
categories: erlang
meta: 
---
Problem Definition: <a href="http://projecteuler.net/index.php?section=problems&amp;id=3">Euler Problem 3</a><br /><br />Obviously, these scripts did not actually implement the solution. The problem statement required to pick the largest factor, but I just realized I had not done it.<br /><br /><pre style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; font-family: Andale Mono,Lucida Console,Monaco,fixed,monospace; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); font-size: 12px; line-height: 14px; width: 100%;"><code><br />"""<br /><br />The prime factors of 13195 are 5, 7, 13 and 29.<br /><br />What is the largest prime factor of the number 317584931803?<br /><br />"""<br /><br />import sys<br /><br />primes = []<br /><br />def isprime(N):<br />  """<br />    Original version use xrange, but caused<br /><br />    "OverflowException: long int too large to convert to int"<br /><br />    when taking in a large number<br />   <br />    So, I have to use while loop to replace "for i in xrange(2, N):"<br /><br />    And in order to speed up the process, the prime calculation result<br />    is cached<br />  """<br />  global primes<br /><br />  # we have already tested it<br />  if N in primes:<br />    return True<br /><br />  # use the prime results first <br />  for i in primes:<br />    if (N % i) == 0:<br />      return False<br /><br />  # now computation is required<br />  maxprime = 2<br />  if len(primes) > 0:<br />    maxprime = primes[-1]<br /><br />  i = maxprime + 1<br />  while i < N:<br />    if (N % i) == 0:<br />      return False<br />    i = i + 1<br /><br />  primes.append(N)<br />  return True<br /><br /><br />def factorise(N):<br />  """<br />    to factorise a integer<br />    <br />  """<br />  # short cut<br />  global primes<br />  res = []<br /><br />  if N in primes:<br />    res.append(N)<br />    return res<br /><br />  # original algorithm<br />  idx = 2<br />  while idx <= N:<br />    if isprime(idx):<br />      div, mod = divmod(N, idx)<br />      if mod == 0:<br />        res.append(idx) <br />        res.extend(factorise(div))<br />        break<br />    idx = idx + 1<br />  return res      <br /><br />if __name__ == "__main__":  <br />  print factorise(int(sys.argv[1]))<br /><br /><br /></code></pre><br /><br /><br /><br />Here comes the erlang version. There is some performance issue with this version. hopefully I would have some free time soon to improve the algorithm.<br /><br /><br /><pre style="border: 1px dashed rgb(153, 153, 153); padding: 5px; overflow: auto; font-family: Andale Mono,Lucida Console,Monaco,fixed,monospace; color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); font-size: 12px; line-height: 14px; width: 100%;"><code><br /><br />-module(p3).<br />-export([isprime/1, factorise/1]).<br /><br />%%<br />%% prime means it is not divisible by any numbers other than 1 and itself.<br />%%<br />isprime(1) -><br /> false;<br /><br />isprime(2) -><br /> true;<br /><br />isprime(N) when N > 2 -><br /> Pid = self(),<br /> C = lists:seq(2, N - 1),<br /> process_flag(trap_exit, true),<br /> lists:map(fun(Div) -><br />               spawn_link(fun() -><br />                   test_if_divisible(Pid, N, Div)<br />                   end)<br />               end, C),<br /> isprime_poll(length(C)).<br /><br /><br />%%<br />%% Message loop: to listen and receive message from voters<br />%%<br />isprime_poll(0) -><br /> true;<br />isprime_poll(NumVote) -><br /> receive<br />   {nondivisible, _} -><br />       isprime_poll(NumVote - 1);<br />   {divisible, _} -><br />       clean_mailbox(),<br />       false<br /> end.<br /><br />%%<br />%% To clear away any messages in mailbox<br />%%<br />clean_mailbox() -><br /> receive<br />   _ -><br />     clean_mailbox()<br />   after 0 -> ok<br /> end.<br /><br />%%<br />%%<br />%%<br />test_if_divisible(Pid, N, Div) -><br /> case N rem Div of<br />   0 -> Pid ! {divisible, Div};<br />   _ -> Pid ! {nondivisible, Div}<br /> end.<br /><br />%%%<br />%%% To factorise an integer - wrappers<br />%%%<br />factorise(N) when is_list(N) -><br />   N1 = string:to_integer(N),<br />   factorise(N1, 2, []);<br /><br />factorise(N) -><br />   factorise(N, 2, []).<br /><br />%%%<br />%%% To factorise an integer<br />%%%<br />factorise(N, Factor, Result) when Factor < N+1  -><br /> case isprime(Factor) of<br />   true -><br />     if<br />       (N rem Factor) == 0 -><br />         %% io:format("Residual is 0 by Factor ~p~n", [Factor]),<br />         factorise(N div Factor, 2, [Factor|Result]);<br />       true -><br />         factorise(N, Factor + 1, Result)<br />     end;<br />   false -><br />       factorise(N, Factor + 1, Result)<br /> end;<br /><br />factorise(_, _, Result) -><br /> R = lists:reverse(Result),<br /> %% io:format("~p~n", [R]),<br /> R.<br /><br /></code></pre>