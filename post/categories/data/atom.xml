<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: data | Timeline]]></title>
  <link href="http://www.ahwkong.com/post/categories/data/atom.xml" rel="self"/>
  <link href="http://www.ahwkong.com/"/>
  <updated>2015-03-18T06:47:43+11:00</updated>
  <id>http://www.ahwkong.com/</id>
  <author>
    <name><![CDATA[Anthony Kong]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ex 2.2]]></title>
    <link href="http://www.ahwkong.com/post/2014/08/29/ex-2-dot-2/"/>
    <updated>2014-08-29T14:59:00+10:00</updated>
    <id>http://www.ahwkong.com/post/2014/08/29/ex-2-dot-2</id>
    <content type="html"><![CDATA[<p><strong>Exercise 2.2</strong> (Andersson [And91D]) In the worst case, member performs approximately 2d comparisons, where d is the depth of the tree. Rewrite member to take no more than d + 1 comparisons by keeping track of a candidate element that might be equal to the query element (say, the last element for which &lt; returned false or &lt; returned true) and checking for equality only when you hit the bottom of the tree.)</p>

<p><strong>Answer</strong></p>

<p>To test the example code, run these commands:</p>

<pre><code>erl -noshell -noinit -run ex2_2 test_insert -run init stop
erl -noshell -noinit -run ex2_2 test_member -run init stop
</code></pre>

<p>My erlang implementation actually does not have the same performance characteristic as stated in the question. The code in question is this:</p>

<p>{% codeblock lang:ocaml %}</p>

<p>fun member (x, E) = false
  | member (x, T (a, y, b)) =</p>

<pre><code>    If Element.lt (x, y) then member (x, a)
    else if Element.lt (y, x) then member (x, b) 
    else true
</code></pre>

<p>{% endcodeblock %}</p>

<p>The <code>if</code> clause in the above function will cause the <code>Element.lt</code> to be executed twice per node visit in the worst case scenarios. Hence the 2 * d comparisons.</p>

<p>It does not really apply to my erlang version of code because pattern matching has shortcircuted the comparsion when there is a match. The comparsion is done by the <code>guard</code>. In a sense I cheated: I did not use a functor to compare the values. This enables me to use the pattern matching.</p>

<p>{% codeblock lang:erlang %}
-module(ex2_2).
-export([make_sample_tree/0, test_insert/0, test_traverse/0, test_member/0]).</p>

<p>-record(treenode, {key, value}).
-record(tree, {left, treenode=#treenode{}, right}).</p>

<p>make_node(K, V) &ndash;></p>

<pre><code>TN = #treenode{key=K, value=V},
T = #tree{treenode=TN},
T.
</code></pre>

<p>make_node(K, V, LeftTree, RightTree) &ndash;></p>

<pre><code>TN = #treenode{key=K, value=V},
T = #tree{treenode=TN, left=LeftTree, right=RightTree},
T.
</code></pre>

<p>insert_tree_node(undefined, K, V) &ndash;></p>

<pre><code>make_node(K, V);
</code></pre>

<p>insert_tree_node(#tree{left=LT, treenode=#treenode{key=CurK, value=<em>CurV}, right=</em>RT}=T, K, V) when K &lt; CurK  &ndash;></p>

<pre><code>LT1=insert_tree_node(LT, K, V),
T1=T#tree{left=LT1},
T1;
</code></pre>

<p>insert_tree_node(#tree{left=<em>LT, treenode=#treenode{key=CurK, value=</em>CurV}, right=RT}=T, K, V) when K > CurK  &ndash;></p>

<pre><code>RT1=insert_tree_node(RT, K, V),
T1=T#tree{right=RT1},
T1;
</code></pre>

<p>% when K == CurK
insert_tree_node(T, _K, V)  when is_record(T, tree) &ndash;></p>

<pre><code>T#tree{treenode=#treenode{value=V}}.
</code></pre>

<p>traverse(F, Tree) when is_record(Tree, tree) and is_function(F) &ndash;></p>

<pre><code>traverse(F, Tree, 0).
</code></pre>

<p>traverse(<em>F, undefined, </em>D) &ndash;> ok;
traverse(F, Tree, D) when is_record(Tree, tree) and is_function(F) &ndash;> % F is a function that work on K and V</p>

<pre><code>traverse(F, Tree#tree.left, D+1),
F(Tree#tree.treenode#treenode.key, Tree#tree.treenode#treenode.value, D),
traverse(F, Tree#tree.right, D+1).
</code></pre>

<p>member(K, #tree{treenode=#treenode{key=K}}=Tree) &ndash;></p>

<pre><code>found;
</code></pre>

<p>member(K, #tree{treenode=#treenode{key=CurK}}=Tree) when K &lt; CurK &ndash;></p>

<pre><code>% io:format("Compared for ~p~n", [K]),
member(K, Tree#tree.left);
</code></pre>

<p>member(K, #tree{treenode=#treenode{key=CurK}}=Tree) when K > CurK &ndash;></p>

<pre><code>% io:format("Compared for ~p~n", [K]),
member(K, Tree#tree.right);
</code></pre>

<p>member(K, undefined) &ndash;></p>

<pre><code>not_found.
</code></pre>

<p>%% routines for testings
%%
make_sample_tree() &ndash;></p>

<pre><code>Left = make_node(1, 1),
Right = make_node(5, 5),
T = make_node(3, 3, Left, Right),
T.
</code></pre>

<p>make_sample_tree2() &ndash;></p>

<pre><code>T = make_node(5, 5),
T1 = insert_tree_node(T, 1, 1),
T2 = insert_tree_node(T1, 2, 2),
T3 = insert_tree_node(T2, 7, 7),
T4 = insert_tree_node(T3, 6, 6),
T5 = insert_tree_node(T4, 10, 10),
T6 = insert_tree_node(T5, 12, 12),
T6.
</code></pre>

<p>test_insert() &ndash;></p>

<pre><code>T = make_sample_tree(),
T1 = insert_tree_node(T, 7, 7),
io:format("old ~p~n", [T]),
io:format("new ~p~n", [T1]).
</code></pre>

<p>test_traverse() &ndash;></p>

<pre><code>F = fun (K, V, _D) -&gt; io:format("key:~p val:~p~n", [K, V]) end,
T = make_sample_tree(),
traverse(F, T).
</code></pre>

<p>test_member() &ndash;></p>

<pre><code>T = make_sample_tree2(),
F = fun (K, V, Depth) -&gt;
        Indent = string:chars($\s, Depth*4), 
        io:format("~skey:~p val:~p~n", [Indent, K, V]) 
    end,
traverse(F, T),
R1 = member(12, T),
R2 = member(-1, T),
io:format("R1:~p R2:~p~n", [R1, R2]).
</code></pre>

<p>{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ex 2.1]]></title>
    <link href="http://www.ahwkong.com/post/2014/08/27/ex-1/"/>
    <updated>2014-08-27T10:02:00+10:00</updated>
    <id>http://www.ahwkong.com/post/2014/08/27/ex-1</id>
    <content type="html"><![CDATA[<p><strong>Exercise 2.1</strong> Write a function suffixes of type a list &ndash;> a list of list that takes a list xs and returns a list of all the suffixes of xs in decreasing order of length. For example,</p>

<pre><code>suffixes [1,2,3,4] = [[1,2,3,4], [2,3,4], [3,4], [4], [ ] ]
</code></pre>

<p>Show that the resulting list of suffixes can be generated in O(n) time and represented in O(n) space.</p>

<p>{% codeblock lang:erlang %}</p>

<p>-module(e2_1).</p>

<p>-export([suffixes/1]).</p>

<p>suffixes(L) &ndash;> suffixes(L, []).</p>

<p>suffixes([H|T], R)</p>

<pre><code>-&gt; suffixes(T, [[H|T]|R]);
</code></pre>

<p>suffixes([], R) &ndash;> lists:reverse([[]|R]).</p>

<p>{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
